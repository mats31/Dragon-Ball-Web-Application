<div id="container"></div>

<script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
<script type="text/javascript">
	// set the scene size
	var WIDTH = window.innerWidth,
	  	HEIGHT = window.innerHeight;

	// set some camera attributes
	var VIEW_ANGLE = 45,
		ASPECT = WIDTH / HEIGHT,
	  	NEAR = 0.1,
	  	FAR = 1000,
	  	canvas = document.createElement('canvas'),
	  	context = canvas.getContext('2d'),
	  	img = new Image(),
	  	DENSITY			= 3,
	  	orbitValue = 0,
	  	ORBIT_RATE		= 0.01,
	  	DEPTH			= Math.max(WIDTH, HEIGHT);

	  	img.src = 'giphy.gif';

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#container');

	// create a WebGL renderer, camera
	// and a scene
	var renderer = new THREE.WebGLRenderer();
	var camera =
	  new THREE.PerspectiveCamera(
	    VIEW_ANGLE,
	    ASPECT,
	    NEAR,
	    FAR);

	var scene = new THREE.Scene();

	// add the camera to the scene
	scene.add(camera);

	// the camera starts at 0,0,0
	// so pull it back
	camera.position.z = 1000;

	// start the renderer
	renderer.setSize(WIDTH, HEIGHT);

	// attach the render-supplied DOM element
	$container.append(renderer.domElement);

	img.onload = function(){

		canvas.width = img.width;
	  	canvas.height = img.height;

		context.drawImage(img,0,0,img.width,img.height);

		// create the particle variables
		var particleCount = 1800,
		    particles = new THREE.Geometry();

		var particleTexture = THREE.ImageUtils.loadTexture("particle.png");

		var pMaterial = new THREE.PointCloudMaterial({
			blending: THREE.AdditiveBlending,
			map: particleTexture,
			size: DENSITY * 1.5,
			opacity: 1,
			vertexColors:true,
			sizeAttenuation:true
		});
		var pixels = context.getImageData(0,0,img.width,img.height),
			step = DENSITY * 4,
			x = 0,
			y = 0;

		// for (var i = 0; i < pixels.data.length; i+=4) {
		// 	pixels.data[i]
		// };

	 	for(x = 0; x < img.width * 4; x+= step)
	    {
	    	for(y = img.height; y >= 0 ; y -= DENSITY)
	    	{
	    		var p = ((y * img.width * 4) + x);
	    		
	    		// grab the actual data from the
	    		// pixel, ignoring any transparent ones
	    		if(pixels.data[p+3] > 0)
			    {
			    	var pixelCol	= (pixels.data[p] << 16) + (pixels.data[p+1] << 8) + pixels.data[p+2];
			    	var color 		= new THREE.Color(pixelCol);
			    	var vector 		= new THREE.Vector3(-300 + x/4, 240 - y, 0);
			    	
			    	// push on the particle
			    	particles.vertices.push(vector);
			    	particles.colors.push(color);
			    }
	    	}
	    }

		//console.log(particles);

	    // // now create the individual particles
	    // for (var p = 0; p < particleCount; p++) {

	    //   // create a particle with random
	    //   // position values, -250 -> 250
	    //   var pX = Math.random() * 500 - 250,
	    //       pY = Math.random() * 500 - 250,
	    //       pZ = Math.random() * 500 - 250,
	    //       particle = new THREE.Vector3(pX, pY, pZ);

	    //   // add it to the geometry
	    //   particles.vertices.push(particle);
	    // }

	    var geometry = new THREE.BoxGeometry( 1, 1, 1 );
	    var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
	    var cube = new THREE.Mesh( geometry, material );
	    scene.add( cube );

	    // create the particle system
	    var particleSystem = new THREE.PointCloud(
	        particles,
	        pMaterial);

	    // also update the particle system to
		// sort the particles which enables
		// the behaviour we want
		particleSystem.sortParticles = true;

	    // add it to the scene
	    scene.add(particleSystem);	

	    update();	

		function update(){
			requestAnimationFrame(update);

			render();
		};

		// draw!
		function render(){
			var timer = Date.now() * 0.0002;

		  	//camera.position.x = Math.cos( timer ) * 1500;
		  	//camera.position.z = Math.sin( timer ) * 1500;

			camera.lookAt(scene.position);
		  	
			renderer.render(scene, camera);
		}

		//$container.append(canvas);

	};



</script>